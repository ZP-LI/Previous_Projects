## Structure of this GitLab-Repository

**Branch "main"**. The final vision of the challenge. Download the src-folder and follow the procedure below.

**Branch "Xinyu"**. Beta vision of the challenge. Currently a new map is used under the "/stdr_move_base" package.

**Other Branch**. The branch of each group member to do their own tasks. Will not be used anymore.


##  Setup

**Step 1**. If not already done so, install [ROS](http://wiki.ros.org/ROS/Installation) (Desktop-Full is recommended).

**Step 2**. Download the Unity executable files. 
    
**Step 3**. Install [depth-image-proc](http://wiki.ros.org/depth_image_proc).

sudo apt-get install ros-noetic-depth-image-proc  

**Step 4**. Install [Octomap](http://wiki.ros.org/octomap).

sudo apt-get install ros-noetic-octomap-ros 
sudo apt-get install ros-noetic-octomap-msgs
sudo apt-get install ros-noetic-octomap-server
sudo apt-get install ros-noetic-octomap-rviz-plugins 

**Step5**  Install ``gmapping`` and ``map-server``

sudo apt install ros-noetic-gmapping
sudo apt install ros-noetic-map-server


## Getting Started

1. Copy the src-folder to your repository and build it
2. Download the Unity Environment: https://syncandshare.lrz.de/getlink/fi3YWNfndrPTpXXkCT9sKvM9/
3. Unzip the Unity file and copy the files to .../devel/lib/simulation/


## Point cloud && Octomap

### step1:

arrive the special file path:

cd ~/.../project
catkin build

## step2:

``Terminal1``: use the keyboard to move the robot, by 

source devel/setup.bash
rosrun controller_pkg controller_node.cpp
rosrun teleop_twist_keyboard_cpp teleop_twist_keyboard.cpp

 Moving around by the keyboard:
   				u    i    o
   				j    k    l
   			    m    <    >

``Terminal2``: launch the pointcloud2

source devel/setup.bash
roslaunch simulaition point_cloud.launch

``Terminal3``: launch the octomap

source devel/setup.bash
roslaunch simulation octomap_mapping.launch

``Terminal4``: launch the rviz

source devel/setup.bash
roslaunch simulation rviz.launch


## Controller

### step1:

arrive the special file path:

cd ~/.../project
catkin build

## step2:

``Terminal1``: open the simulation Unity

source devel/setup.bash
roslaunch simulation simulation.launch

`Terminal2`: launch the controller

source devel/setup.bash
rosrun controller_pkg controller_node_li

``Terminal3``: run move_base package to generate the path

source devel/setup.bash
roslaunch stdr_move_base path.launch
Klick the bottom "2D Nav Goal", then select a goal that points in a certain direction
Then the robot starts to move!

The set of the terminal can be seen from the snapshot "terminal_control.png" under this branch.


## Used ROS Node Description

"/stdr_move_base": all the information that generated by the package "move_base"

"/stdr_move_base/TrajectoryPlannerROS/global_plan": desired points provided by the package "move_base"

"/current_state_est": current position and orientation of the robot

"/rotor_speed_cmds": Control signals to control the robot in form [vel_cmd, turn_cmd, amp_cmd, 0]'


## Basic Process for map generation

The quadruped robot walks the entire path via keyboard control and scans the simulated environment with a depth camera.

1.Convert the depth map to a point cloud map. Add PointCloud2 in rviz.
2.Convert the point cloud map to a octomap. Add OccupancyMap in rviz.
3.Add Map in rviz.
4.Save the map.(rosrun map_server map_saver -f map1 map:=/projected_map)
5.Convert map to costmap for path planning and trajectory planning


## Basic idea of control code

All control codes are integrated in the file "src/controller_pkg/concontroller_node.cpp"

Subscribe to the current position and orientation of the robot from "/current-state-est".
Subscribe to the desired position of the robot from "/global-plan".

Calculate the desired orientation based on the current position and the desired position.

The forward control speed of the robot is set to the absolute value of the difference between the current position and the desired position.

Mode 1: When the difference between the current orientation and the desired orientation is greater than 32 degrees, the parameter "state_M" changes from 0 to 1, and the steering mode is turned on. In this mode, the forward speed is 0.1 and the steering speed is 4.8.

Adaptive Mode: When the difference between the current orientation and the desired orientation is less than 32 degrees, different steering speeds will be generated according to the size of the error angle.

Mode 2: When the robot has no position change for a long time, it means that the robot reaches the first obstacle, the parameter "state_M2" changes from 0 to 1, and starts to "cross the obstacle" mode.


## Encountered and current Problems

1. It is worth mentioning here that at the very start we wanted to subscribe to the topic "/local_plan" provided by the "move_base" package to directly get the desired orientation, but after looking at the messages provided by each loop of "/local_plan", we found that the provided position and orientation from the "/local_plan" are not points along the optimal path, but the positions the robot can reach in next timestep (not just the points on the optimal path) and the orientations to those positions. So in the end we decided to subscribe to the topic "/global_plan" to get the desired position and calculate the desired orientation by ourselves.

2. The topic "/global-plan" provides in each loop the position of the next 63 points along the optimal path from the robot's current position. In order to ensure that the calculated robot control parameters have a certain forward-looking and are not affected by the environment too much, we decided to subscribe the 30th point provided by "/global-plan" as the desired position [Line 148-169 in file "src/controller_pkg/src/controller_node.cpp"]

3. We tried many different sets of control parameter combinations, all without success over the first obstacle. In the current situation, our robot's front legs can climb the obstacle, but the hind legs can't, so it can't reach the goal. Details about this situation are in the videos under this branch: "video1.mp4" and "video2.mp4".

Ideas we have tried include: 
after reaching the first obstacle, let the robot step back a few loops and then slowly move forward; 
alternately using different Amplitude control parameters, such as (in one cycle, in the first 3 loops the control parameter for amplitude "amp_cmd" is set to 0.1, in the last loop "amp_cmd" is set to 4); 
raise the robot legs high first, then slowly move forward, etc.

In addition, we tried various combinations of speed control parameters from [0.0-2.0], rotation control parameters from [0.0-12.8], and amplitude control parameters from [0.01-4.0]


## Advantages of the current Code

The path provided by the "move_base" package is the optimal path. The path at the corner is too close to the corner. If the robot moves completely along the path, it will cause the robot to collide with the road post at the corner. Our code will only fully switch to steering mode when the error angle is greater than 32 degrees, and adopt adaptive mode when it is less than 32 degrees, which allows the robot to autonomously choose a non-optimal but safer route.

